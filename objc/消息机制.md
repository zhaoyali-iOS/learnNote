## 引子
我们编写的OC代码最后都会编译成Runtime中的`objc_msgSend`方法去执行，这篇文章我们就具体探讨Runtime消息是怎样一步步传送、解析、转发、执行的。

## 消息机制的主要流程

OC的代码编译成Runtime中的`objc_msgSend(id sel,SEL op, ...)`,这个方法会调用到`lookUpImpOrForward`方法，消息机制的主要过程就是在这个方法中实现的
```objectivec
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil;
    bool triedResolver = NO;

    runtimeLock.assertUnlocked();

    // Optimistic cache lookup
    if (cache) {
        imp = cache_getImp(cls, sel);
        if (imp) return imp;
    }
    ...
    if (initialize  &&  !cls->isInitialized()) {
        runtimeLock.unlock();
        _class_initialize (_class_getNonMetaClass(cls, inst));
        runtimeLock.lock();
        // If sel == initialize, _class_initialize will send +initialize and 
        // then the messenger will send +initialize again after this 
        // procedure finishes. Of course, if this is not being called 
        // from the messenger then it won't happen. 2778172
    }

    
 retry:    
    runtimeLock.assertLocked();
//1.消息传递，
    //1.1 当前类中查找
    //1.1.1查缓存
    imp = cache_getImp(cls, sel);
    if (imp) goto done;

    //1.1.2 查 method lists. 
    {
        Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {
            //1.1.3 更新缓存
            log_and_fill_cache(cls, meth->imp, sel, inst, cls);
            imp = meth->imp;
            goto done;
        }
    }

    //1.2 逐级查找父类
    {
        unsigned attempts = unreasonableClassCount();
        for (Class curClass = cls->superclass;
             curClass != nil;
             curClass = curClass->superclass)
        {
            //1.2.1 查缓存.
            imp = cache_getImp(curClass, sel);
            if (imp) {
                if (imp != (IMP)_objc_msgForward_impcache) {
                    // Found the method in a superclass. Cache it in this class.
                    //1.2.2 更新缓存，把父类方法缓存当前类的cache中
                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    goto done;
                }
                else {
                    // Found a forward:: entry in a superclass.
                    // Stop searching, but don't cache yet; call method 
                    // resolver for this class first.
                    break;
                }
            }
            
            // 1.2.3 查父类method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                //1.2.4 更新缓存，把父类方法缓存当前类的cache中
                log_and_fill_cache(cls, meth->imp, sel, inst, curClass);
                imp = meth->imp;
                goto done;
            }
        }
    }

    //2. 动态解析
    if (resolver  &&  !triedResolver) {
        runtimeLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        triedResolver = YES;
        goto retry;
    }

    // 3. 消息转发
    imp = (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

 done:
    runtimeLock.unlock();

    return imp;
}

```
由代码可知Runtime的消息机经历了4个步骤
* 1.消息传递
* 2.消息动态解析
* 3.消息转发
* 4.找到IMP就执行，否则就执行`-doesNotRecognizeSelector`

### 1.消息传递
首先会检查当前类是否initialized，这就保证了类对象在接受其他消息前先执行`+initialize`方法。<br/>
这里有个注释解释了一种特殊情况：当前类没有执行initialize且SEL=@selector(initialize)。出现这种情况的场景是：在`_class_initialize`中会给对象发送+initialize消息，这种情况满足if语句时必定initializing为YES，第二次进去`_class_initialize`时类的状态是initializinghini或者initialized，这两种状态都不会发送+initialize消息。同时这里也了解为什么会有一个中间状态initializing了<br/>
查找顺序：
* 沿继承关系，从当前类逐级向上查找
* 每一级中，先查找cache中，找不到是再查找method list，在method list中找到后，都缓存在开始查找类的cache中。class的cache中有可能缓存父类的方法
* 在父类中找到了forward方法，不缓存到cache，但要执行。不缓存是为了保证消息机制中resolver优先的原则，如果缓存上转发的消息的IMP(cache中有非本类非父类实现的方法)，下次其他实例在执行此方法时，就会直接从类的cache中直接获取到IMP，就不会走到resolver的逻辑了


### 2.消息动态解析
在消息传递的过程中找不到对应的IMP，这个时候如果参数resolver为YES且第一次执行`retry`代码快，就会进入if语句执行`_class_resolveMethod`方法,这个方法会调用到`_class_resolveInstanceMethod`方法
```objectivec
static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)
{
  //如果没有找到+resolveInstanceMethod实现，直接返回
    if (! lookUpImpOrNil(cls->ISA(), SEL_resolveInstanceMethod, cls, 
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) 
    {
        return;
    }
  //找到之后添加到当前类的cache中
    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    ...
}
```
_class_resolveMethod执行完毕之后，重新开始消息机制（会再次执行retry代码块），这次可能在1.1.1步就会找到IMP然后直接返回IMP；也可能遍历所有父类仍然没找到，这时候triedResolver为YES，不会在进入步骤2直接执行3的逻辑<br/>
实例方法和类方法的resolve过程类似，这里就不在赘述


### 3.消息转发
前两步都没有找到对应的IMP，第三部就进行转发处理，直接获取`_objc_msgForward_impcache`的IMP并缓存，然后执行<br/>
objc_msgForward方法没有开源，但我们都知道会触发两个方法`-methodSignatureForSelector`和`-forwardingInvocation`<br/>
假设要重定向的消息是xx_dealNotRecognizedMessage:，重定向的对象是XXForwardProxy实例<br/>
`-methodSignatureForSelector`用于重定向消息，并返回方法签名,如果返回nil，则直接结束转发流程
```objectivec
-  (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
         NSMethodSignature *sig =  [XXForwardProxy instanceMethodSignatureForSelector:@selector(xx_dealNotRecognizedMessage:)];
          return sig;
     }
```
`-forwardingInvocation`用于重定向接受者并设置方法参数
```objectivec
- (void)forwardingInvocation:(NSInvocation *)anInvocation {
  NSString *unrecognizedMessage = @“ccccccc”;
  //重新指定方法
  [anInvocation setSelector:@selector(xx_dealNotRecognizedMessage:)];
  [anInvocation setArgument:&unrecognizedMessage atIndex:2];
  //重新指定消息接收者,重新触发消息机制
  [anInvocation invokeWithTarget:[XXForwardProxy new]  ];
}
```
cocoa中很多地方用到消息传递机制来进行语言扩展，NSProxy就是专门用作为代理转发消息的，NSUndoManager截取一个消息后在转发，responderChain(通过nextResponder)保证一个消息转发给合适的响应者


## 总结：
lookUpImpOrForward方法中retry---done语句块应用十分巧妙，尤其是跟lookUpImpOrNil方法一起使用，巧妙避免了重复代码

## 遗留问题
查抄阶段，找到的msg_foword方法为什么不要缓存起来？？？？？
resolver阶段动态添加的方法会添加到methodlist中吗？？？？，这样动态添加的方法有可能会在cache中吗？

